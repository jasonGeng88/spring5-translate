##26.4 接收消息
###26.4.1 同步接收
虽然JMS通常与异步处理相关联，但可以同步地消费消息。 重载的receive（..）方法提供了这个功能。 在同步接收期间，调用线程阻塞，直到接收到消息。 这可能是一个危险的操作，因为调用线程可能无限期地被阻塞。 receiveTimeout属性指定接收者等待消息的超时时间。

###26.4.2 异步接收 - 消息驱动对象
> Spring还通过使用@JmsListener注解来支持带注解的监听器端点，并提供了一种开放的基础设施，以编程方式注册端点。 这是设置异步接收器的最方便的方法，有关详细信息，[请参见第26.6.1节“启用侦听器端点注释”](http://docs.spring.io/spring/docs/5.0.0.M5/spring-framework-reference/html/jms.html#jms-annotated-support)。

类似于EJB世界中的消息驱动Bean（MDB）的方式，消息驱动的POJO（MDP）充当JMS消息的接收器。 MDP上的一个限制（但是也参见下面的MessageListenerAdapter类的讨论）就是必须实现javax.jms.MessageListener接口。 还请注意，如果您的POJO将在多个线程上接收消息，那么确保您的实现是线程安全的，这一点非常重要。

下面是MDP的一个简单实现:

```//java
import javax.jms.JMSException;
import javax.jms.Message;
import javax.jms.MessageListener;
import javax.jms.TextMessage;

public class ExampleListener implements MessageListener {

	public void onMessage(Message message) {
		if (message instanceof TextMessage) {
			try {
				System.out.println(((TextMessage) message).getText());
			}
			catch (JMSException ex) {
				throw new RuntimeException(ex);
			}
		}
		else {
			throw new IllegalArgumentException("Message must be of type TextMessage");
		}
	}

}
```

一旦你实现了MessageListener接口,下面该创建一个消息监听者的容器了。

在下面的例子中展示了如何定义和配置Spring附带的其中一个消息监听器容器（在本例中使用的是DefaultMessageListenerContainer）。

```//java
<!-- this is the Message Driven POJO (MDP) -->
<bean id="messageListener" class="jmsexample.ExampleListener" />

<!-- and this is the message listener container -->
<bean id="jmsContainer" class="org.springframework.jms.listener.DefaultMessageListenerContainer">
	<property name="connectionFactory" ref="connectionFactory"/>
	<property name="destination" ref="destination"/>
	<property name="messageListener" ref="messageListener" />
</bean>
```

请参阅各种消息监听器容器的Spring javadocs，以了解每个实现支持的功能的完整描述。

###26.4.3 SessionAwareMessageListener接口
SessionAwareMessageListener接口是一个特定于Spring的接口，它为JMS MessageListener接口提供了一个类似的契约，同时还提供了一种消息处理方法，可以访问从其接收消息的JMS会话。

```//java
package org.springframework.jms.listener;

public interface SessionAwareMessageListener {

	void onMessage(Message message, Session session) throws JMSException;

}

```

如果希望消息驱动对象能够响应任何收到的消息（使用onMessage（Message，Session）方法中提供的会话），你可以选择让你的消息驱动对象实现此接口（优先于标准JMS MessageListener接口）。 Spring附带的所有消息监听者容器的实现都支持实现MessageListener或SessionAwareMessageListener接口的消息驱动对象。 实现SessionAwareMessageListener在通过接口将其绑定到Spring时会带有警告。是否使用它的选择完全取决于作为应用程序开发人员或架构师的你。

请注意，SessionAwareMessageListener接口的'onMessage（..）'方法会抛出JMSException。 与标准的JMS MessageListener接口相比，当使用SessionAwareMessageListener接口时，客户端代码负责处理抛出的任何异常。

###26.4.4 MessageListenerAdapter
MessageListenerAdapter类是Spring的异步消息传递支持中的最后一个组件：简而言之，它允许您将几乎任何类都暴露为MDP（当然有一些限制）。

请考虑以下接口定义。 请注意，虽然该接口既不继承MessageListener，也不继承SessionAwareMessageListener接口，但仍可以通过使用MessageListenerAdapter类作为MDP。 还要注意，各种消息处理方法如何根据可以接收和处理的各种消息类型的内容进行强类型化。

```//java
public interface MessageDelegate {

	void handleMessage(String message);

	void handleMessage(Map message);

	void handleMessage(byte[] message);

	void handleMessage(Serializable message);

}
```

```
public class DefaultMessageDelegate implements MessageDelegate {
	// implementation elided for clarity...
}
```

尤其要注意的是，上述MessageDelegate接口的实现（上述DefaultMessageDelegate类）根本没有JMS依赖关系。 是一个普通的JAVA对象，我们将通过以下配置使它成为MDP。

```//java
<!-- this is the Message Driven POJO (MDP) -->
<bean id="messageListener" class="org.springframework.jms.listener.adapter.MessageListenerAdapter">
	<constructor-arg>
		<bean class="jmsexample.DefaultMessageDelegate"/>
	</constructor-arg>
</bean>

<!-- and this is the message listener container... -->
<bean id="jmsContainer" class="org.springframework.jms.listener.DefaultMessageListenerContainer">
	<property name="connectionFactory" ref="connectionFactory"/>
	<property name="destination" ref="destination"/>
	<property name="messageListener" ref="messageListener" />
</bean>
```

以下是另一个只能处理JMS TextMessage消息的接收的MDP的例子。 注意消息处理方法实际上调用了“receive”（MessageListenerAdapter中消息处理的默认方法名是“handleMessage”），但它是可配置的（如下所示）。 还要注意，“receive（..）”方法是如何强类型的只对JMS TextMessage消息做出接收和响应的。

```//java
public interface TextMessageDelegate {

	void receive(TextMessage message);

}
```

```//java
public class DefaultTextMessageDelegate implements TextMessageDelegate {
	// implementation elided for clarity...
}
```

伴随的MessageListenerAdapter的配置如下:

```//java
<bean id="messageListener" class="org.springframework.jms.listener.adapter.MessageListenerAdapter">
	<constructor-arg>
		<bean class="jmsexample.DefaultTextMessageDelegate"/>
	</constructor-arg>
	<property name="defaultListenerMethod" value="receive"/>
	<!-- we don't want automatic message context extraction -->
	<property name="messageConverter">
		<null/>
	</property>
</bean>
```

请注意，如果上述'messageListener'接收到不是TextMessage类型的JMS消息，则会抛出IllegalStateException（并随后吞没）。 MessageListenerAdapter类的另一个能力是如果处理程序方法有返回值，则会自动发送一个响应消息。 考虑接口和类：

```//java
public interface ResponsiveTextMessageDelegate {

	// notice the return type...
	String receive(TextMessage message);

}
```

```//java
public class DefaultResponsiveTextMessageDelegate implements ResponsiveTextMessageDelegate {
	// implementation elided for clarity...
}
```

如果将上述DefaultResponsiveTextMessageDelegate与MessageListenerAdapter结合使用，那么从执行'receive（..）'方法返回的任何非空值都将（在默认配置中）转换为TextMessage。 然后将生成的TextMessage发送到在原始消息中JMS Reply-目的地（如果存在）或MessageListenerAdapter上的默认目标（如果已配置）; 如果没有找到目的地，那么将抛出一个InvalidDestinationException（并且请注意，这个异常不会被吞没，并会在调用堆栈上进行向上传播）。

###26.4.5 在事务中处理消息
在事务中调用消息监听者只需要重新配置监听者容器。

本地资源事务可以通过监听器容器上定义的sessionTransacted标志进行简单地激活。 然后，每个消息监听器调用将在激活的JMS事务中进行操作，并在监听器执行失败的情况下进行消息回滚。 发送响应消息（通过SessionAwareMessageListener）将成为同一本地事务的一部分，但任何其他资源操作（如数据库访问）将独立运行。 在监听器的实现中通常需要进行重复消息的检测，覆盖数据库处理已经提交但消息处理提交失败的情况。

```//java
<bean id="jmsContainer" class="org.springframework.jms.listener.DefaultMessageListenerContainer">
	<property name="connectionFactory" ref="connectionFactory"/>
	<property name="destination" ref="destination"/>
	<property name="messageListener" ref="messageListener"/>
	<property name="sessionTransacted" value="true"/>
</bean>
```

对于参与外部管理的事务，您将需要配置一个事务管理器并使用支持外部管理事务的监听器容器：通常为DefaultMessageListenerContainer。

要配置XA事务参与的消息监听器容器，您需要配置一个JtaTransactionManager（默认情况下，它将委托给Java EE服务器的事务子系统）。 请注意，基础JMS ConnectionFactory需要具有XA能力并且正确地注册到你的JTA事务协调器上！ （检查你的Java EE服务的JNDI资源配置。）这允许消息接收以及例如同一事务下的数据库访问（具有统一提交语义，以XA事务日志开销为代价）。

```//java
<bean id="transactionManager" class="org.springframework.transaction.jta.JtaTransactionManager"/>
```

然后,你只需要将它添加到我们之前的容器配置中。其余的交给容器处理。

```//java
<bean id="jmsContainer" class="org.springframework.jms.listener.DefaultMessageListenerContainer">
	<property name="connectionFactory" ref="connectionFactory"/>
	<property name="destination" ref="destination"/>
	<property name="messageListener" ref="messageListener"/>
	<property name="transactionManager" ref="transactionManager"/>
</bean>
```