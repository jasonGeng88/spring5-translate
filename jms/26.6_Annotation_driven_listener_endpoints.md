##26.6 注解驱动的监听端点
异步接收消息的最简单的方法是使用注解监听端点基础设施。 简而言之，它允许您将托管bean的方法公开为JMS监听端点。

```//java
@Component
public class MyService {

	@JmsListener(destination = "myDestination")
	public void processOrder(String data) { ... }
}
```

上述示例的想法是，每当javax.jms.Destination“myDestination”上有消息可用时，调用相应地processOrder方法（在这种情况下，与JMS消息的内容类似于MessageListenerAdapter提供的内容）。

注解端点的基础设施使用JmsListenerContainerFactory为每个注解方法创建一个消息监听容器。这样的容器没有针对应用上下文进行注册，但是可以使用JmsListenerEndpointRegistry bean进行简单的管理。

> @JmsListener是Java 8上的可重复注解，因此可以通过向其添加额外的@JmsListener声明将多个JMS目标关联到同一个方法。 在Java 6和7上，您可以使用@JmsListeners注解。

###26.6.1 启用监听端点注解
要启用对@JmsListener注解的支持，请将@EnableJms添加到您的一个@Configuration类中。

```//java
@Configuration
@EnableJms
public class AppConfig {

	@Bean
	public DefaultJmsListenerContainerFactory jmsListenerContainerFactory() {
		DefaultJmsListenerContainerFactory factory =
				new DefaultJmsListenerContainerFactory();
		factory.setConnectionFactory(connectionFactory());
		factory.setDestinationResolver(destinationResolver());
		factory.setConcurrency("3-10");
		return factory;
	}
}
```

默认情况下，基础设施将查找名为jmsListenerContainerFactory的bean作为用于创建消息监听容器的工厂源。 在这种情况下，忽略JMS基础设施设置，可以调用processOrder方法，其核心轮询大小为3个线程，线程池最大为10个线程。

对于使用的每个注解都可以自定义监听容器工厂,或通过实现JmsListenerConfigurer接口来显示的配置默认值。只用当至少有一个端点被注册的端点没有特定的容器工厂时，才需要默认值。 有关详细信息和示例，请参阅javadoc。

如果您喜欢XML配置，请使用<jms：annotation-driven>元素。

```//java
<jms:annotation-driven/>

   <bean id="jmsListenerContainerFactory"
           class="org.springframework.jms.config.DefaultJmsListenerContainerFactory">
       <property name="connectionFactory" ref="connectionFactory"/>
       <property name="destinationResolver" ref="destinationResolver"/>
       <property name="concurrency" value="3-10"/>
   </bean>
```

###26.6.2 编程式端点注册
JmsListenerEndpoint提供了JMS端点的模型，并负责为该模型配置容器。 基础设施允许您除了通过JmsListener注解来检测端点外，还可以以编程方式配置端点。

```//java
@Configuration
@EnableJms
public class AppConfig implements JmsListenerConfigurer {

	@Override
	public void configureJmsListeners(JmsListenerEndpointRegistrar registrar) {
		SimpleJmsListenerEndpoint endpoint = new SimpleJmsListenerEndpoint();
		endpoint.setId("myJmsEndpoint");
		endpoint.setDestination("anotherQueue");
		endpoint.setMessageListener(message -> {
			// processing
		});
		registrar.registerEndpoint(endpoint);
	}
}
```

在上面的例子中，我们使用了SimpleJmsListenerEndpoint，它提供了实际的MessageListener来调用，但是你也可以构建自己的端点变体来描述自定义调用机制。

应该注意的是，您也可以完全跳过@JmsListener的使用，并且只通过JmsListenerConfigurer以编程方式注册您的端点。

###26.6.3 注解式端点方式签名
到目前为止，我们已经在我们的端点注入了一个简单的String，但实际上它可以有一个非常灵活的方法签名。 我们来重写它，用自定义header注入到Order中：

```//java
@Component
public class MyService {

   	@JmsListener(destination = "myDestination")
   	public void processOrder(Order order, @Header("order_type") String orderType) {
       	...
   	}
}
```

这些是您可以在JMS监听器端点中注入的主要元素：

* 原始javax.jms.Message或其任何子类（当然，它与传入的消息类型相匹配）。
* 对于原生JMS API选择性的访问的javax.jms.Session，例如发送自定义回复。
* 表示收到JMS消息的org.springframework.messaging.Message。 请注意，此消息包含自定义和标准headers（由JmsHeaders定义）。
* @Header注解的方法参数获取特定的header值，包括标准JMS headers。
* @Headers注解参数，必须分配给java.util.Map以获取所有访问头信息。
* 不被支持的类型（即消息和会话）的非注解元素被认为是有效载荷。您可以通过使用@Payload注解参数来使其显式。 您还可以通过添加额外的@Valid来启用验证。

注入Spring Message消息抽象的能力特别有助于受益于传输特定消息中存储的所有信息，而不依赖于特定的传输API。

```//java
@JmsListener(destination = "myDestination")
public void processOrder(Message<Order> order) { ... }
```

方法参数的处理由DefaultMessageHandlerMethodFactory提供，它可以进一步自定义额外的方法参数。 转换和验证支持也可以在这里定制。

例如，如果我们要在处理之前确保我们的Order有效，我们可以使用@Valid对有效负载进行注解，并配置必要的验证器，如下所示：

```//java
@Configuration
@EnableJms
public class AppConfig implements JmsListenerConfigurer {

   	@Override
   	public void configureJmsListeners(JmsListenerEndpointRegistrar registrar) {
       	registrar.setMessageHandlerMethodFactory(myJmsHandlerMethodFactory());
   	}

   	@Bean
   	public DefaultMessageHandlerMethodFactory myHandlerMethodFactory() {
       	DefaultMessageHandlerMethodFactory factory = new DefaultMessageHandlerMethodFactory();
       	factory.setValidator(myValidator());
       	return factory;
   	}
}
```

###26.6.4 响应管理
MessageListenerAdapter中的现有支持已经允许您的方法具有非空返回类型。 在这种情况下，调用的结果被封装在javax.jms.Message中。它的发送地址是原始消息JMSReplyTo头中指定的目标或监听器上配置的默认目标。 现在可以使用消息抽象的@SendTo注解来设置该默认目标。

假定现在我们的processOrder方法应该返回一个OrderStatus，可以按如下方式写入自动发送响应：

```//java
@JmsListener(destination = "myDestination")
@SendTo("status")
public OrderStatus processOrder(Order order) {
   	// order processing
   	return status;
}
```

> 如果您有多个@JmsListener注解方法，您还可以将@SendTo注解放在class上以共享默认的回复目标。

如果您需要以独立传输的方式设置额外的header，则可以返回一个Message，如下所示：

```//java
@JmsListener(destination = "myDestination")
@SendTo("status")
public Message<OrderStatus> processOrder(Order order) {
   	// order processing
   	return MessageBuilder
       	    .withPayload(status)
           	.setHeader("code", 1234)
           	.build();
}
```

如果您需要在运行时计算响应目标，则可以将响应封装在JmsResponse实例中，该实例还提供运行时使用的目标。 前面的例子可以重写如下：

```//java
@JmsListener(destination = "myDestination")
public JmsResponse<Message<OrderStatus>> processOrder(Order order) {
   	// order processing
   	Message<OrderStatus> response = MessageBuilder
       	    .withPayload(status)
           	.setHeader("code", 1234)
           	.build();
	return JmsResponse.forQueue(response, "status");
}
```

