##26.3 发送消息
JmsTemplate包含许多方便发送消息的方法。 有一些发送方法使用javax.jms.Destination对象来指定目标，而使用字符串指定目标的方法用于JNDI查找。 不使用目标参数的send方法使用默认目标。

```//java
import javax.jms.ConnectionFactory;
import javax.jms.JMSException;
import javax.jms.Message;
import javax.jms.Queue;
import javax.jms.Session;

import org.springframework.jms.core.MessageCreator;
import org.springframework.jms.core.JmsTemplate;

public class JmsQueueSender {

	private JmsTemplate jmsTemplate;
	private Queue queue;

	public void setConnectionFactory(ConnectionFactory cf) {
		this.jmsTemplate = new JmsTemplate(cf);
	}

	public void setQueue(Queue queue) {
		this.queue = queue;
	}

	public void simpleSend() {
		this.jmsTemplate.send(this.queue, new MessageCreator() {
			public Message createMessage(Session session) throws JMSException {
				return session.createTextMessage("hello queue world");
			}
		});
	}
}
```

此示例使用MessageCreator回调从提供的Session对象创建文本消息。 通过将引用传递给ConnectionFactory来构造JmsTemplate。 或者，提供零参数构造函数和connectionFactory，并可用于以JavaBean方式构建实例（使用BeanFactory或纯Java代码）。 或者，考虑从Spring的JmsGatewaySupport便利基类派生，该类为JMS配置提供预构建的bean属性。

方法send（String destinationName，MessageCreator creator）允许你使用目标的字符串名称发送消息。 如果这些名称在JNDI中注册，则应将模板的destinationResolver属性设置给JndiDestinationResolver实例。

如果创建了JmsTemplate并指定了默认目标，那么send（MessageCreator c）会向该目标发送消息。

###26.3.1 使用消息转换器
为了方便发送领域模型对象，JmsTemplate有各种发送方法，将Java对象作为消息数据内容的参数。 在JmsTemplate中的重载方法convertAndSend（）和receiveAndConvert（）将转换过程委托给MessageConverter接口的一个实例。 该接口定义了一个简单的契约，用于在Java对象和JMS消息之间进行转换。 SimpleMessageConverter的默认实现支持在String和TextMessage，byte []和BytesMesssage以及java.util.Map和MapMessage之间进行转换。 通过使用转换器，你和你的应用程序代码可以专注于通过JMS发送或接收的业务对象，而不关心如何将其作为JMS消息进行表示的细节。

沙箱目前包括一个MapMessageConverter，它使用反射来在JavaBean和MapMessage之间进行转换。 你可能实现的其他常用实现选择是使用现有XML编组包（如JAXB，Castor或XStream）来创建表示对象的TextMessage。

为了适应不能统一封装在转换器类中的消息的属性，标题和主体的设置，MessagePostProcessor接口可以在消息转换后，但在发送之前访问该消息。 下面的示例演示了如何在将java.util.Map转换为消息后修改消息头和属性。

```//java
public void sendWithConversion() {
	Map map = new HashMap();
	map.put("Name", "Mark");
	map.put("Age", new Integer(47));
	jmsTemplate.convertAndSend("testQueue", map, new MessagePostProcessor() {
		public Message postProcessMessage(Message message) throws JMSException {
			message.setIntProperty("AccountID", 1234);
			message.setJMSCorrelationID("123-00001");
			return message;
		}
	});
}
```

修改后的消息内容如下:

```
MapMessage={
	Header={
		... standard headers ...
		CorrelationID={123-00001}
	}
	Properties={
		AccountID={Integer:1234}
	}
	Fields={
		Name={String:Mark}
		Age={Integer:47}
	}
}

```

###26.3.2 SessionCallback和ProducerCallback
虽然发送操作涵盖许多常见的使用场景，但是有时您希望在JMS会话或MessageProducer上执行多个操作。 SessionCallback和ProducerCallback分别公开了JMS Session和Session / MessageProducer对。 JmsTemplate上的execute（）方法执行这些回调方法。



